# SQL Intermedio con PostgreSQL: Consultas Complejas y Lógica de Negocio

En esta sección, las consultas se vuelven más complejas, permitiendo análisis más profundos y la implementación de lógica de negocio usando **PostgreSQL** y la base de datos **Northwind**.

## 1. Uniones de Tablas Avanzadas (`JOIN`)

### `LEFT JOIN`
**Objetivo:** Devolver todas las filas de la tabla izquierda y las filas coincidentes de la tabla derecha. Si no hay coincidencia, el resultado es `NULL` en el lado derecho.

35. **Listar todos los clientes y los pedidos que han realizado. Incluir clientes que no han hecho pedidos.**
    ```sql
    SELECT c.contact_name, o.order_id
    FROM customers c
    LEFT JOIN orders o ON c.customer_id = o.customer_id;
    ```

36. **Mostrar todos los productos y, si han sido pedidos, la cantidad vendida. Incluir productos nunca vendidos.**
    ```sql
    SELECT p.product_name, od.quantity
    FROM products p
    LEFT JOIN order_details od ON p.product_id = od.product_id;
    ```

### `RIGHT JOIN`
**Objetivo:** Devolver todas las filas de la tabla derecha y las filas coincidentes de la tabla izquierda. Es menos común que `LEFT JOIN`.

37. **Listar todos los empleados y los pedidos que han gestionado. Incluir empleados que no han gestionado pedidos.**
    ```sql
    SELECT e.first_name, e.last_name, o.order_id
    FROM orders o
    RIGHT JOIN employees e ON o.employee_id = e.employee_id;
    ```

### `JOIN` con Múltiples Tablas
**Objetivo:** Combinar datos de tres o más tablas.

38. **Para el pedido 10250, mostrar el nombre del cliente, el nombre del producto y la cantidad.**
    ```sql
    SELECT c.contact_name, p.product_name, od.quantity
    FROM orders o
    JOIN customers c ON o.customer_id = c.customer_id
    JOIN order_details od ON o.order_id = od.order_id
    JOIN products p ON od.product_id = p.product_id
    WHERE o.order_id = 10250;
    ```

39. **Mostrar el nombre del cliente, el empleado que lo atendió y el transportista para cada pedido.**
    ```sql
    SELECT o.order_id, c.contact_name, e.first_name AS employee, s.company_name AS shipper
    FROM orders o
    JOIN customers c ON o.customer_id = c.customer_id
    JOIN employees e ON o.employee_id = e.employee_id
    JOIN shippers s ON o.ship_via = s.shipper_id;
    ```

## 2. Subconsultas (Subqueries)

**Objetivo:** Anidar una consulta `SELECT` dentro de otra consulta.

### Subconsulta en la Cláusula `WHERE`
40. **Encontrar todos los productos suministrados por proveedores de Japón.**
    ```sql
    SELECT product_name
    FROM products
    WHERE supplier_id IN (SELECT supplier_id FROM suppliers WHERE country = 'Japan');
    ```

41. **Listar los clientes que han realizado pedidos después del '1998-03-01'.**
    ```sql
    SELECT contact_name
    FROM customers
    WHERE customer_id IN (SELECT customer_id FROM orders WHERE order_date > '1998-03-01');
    ```

### Subconsulta en la Cláusula `FROM`
42. **Calcular el promedio de la cantidad de productos por pedido.**
    ```sql
    SELECT AVG(total_products)
    FROM (SELECT order_id, COUNT(product_id) AS total_products FROM order_details GROUP BY order_id) AS order_counts;
    ```

### Subconsulta Correlacionada
**Objetivo:** Una subconsulta que depende de la consulta externa para sus valores. Se ejecuta una vez por cada fila de la consulta externa.

43. **Encontrar productos cuyo precio es superior al precio promedio de los productos de su misma categoría.**
    ```sql
    SELECT product_name, unit_price
    FROM products p1
    WHERE p1.unit_price > (SELECT AVG(unit_price) FROM products p2 WHERE p2.category_id = p1.category_id);
    ```
    
58. **(Extra) Encontrar los pedidos que contienen el producto 'Chai'**
    ```sql
    SELECT * FROM orders
    WHERE order_id IN (
        SELECT order_id FROM order_details
        WHERE product_id = (SELECT product_id FROM products WHERE product_name = 'Chai')
    );
    ```

## 3. Cláusula `HAVING`

**Objetivo:** Filtrar grupos basados en una condición de agregación, a diferencia de `WHERE` que filtra filas.

44. **Encontrar países con más de 5 clientes.**
    ```sql
    SELECT country, COUNT(*)
    FROM customers
    GROUP BY country
    HAVING COUNT(*) > 5;
    ```

45. **Listar los empleados que han gestionado más de 80 pedidos.**
    ```sql
    SELECT employee_id, COUNT(order_id)
    FROM orders
    GROUP BY employee_id
    HAVING COUNT(order_id) > 80;
    ```

46. **Mostrar las categorías donde el precio promedio del producto es mayor a $30.**
    ```sql
    SELECT category_id, AVG(unit_price)
    FROM products
    GROUP BY category_id
    HAVING AVG(unit_price) > 30;
    ```
    
59. **(Extra) Mostrar los proveedores que suministran más de 3 productos.**
    ```sql
    SELECT s.contact_name, COUNT(p.product_id) AS number_of_products
    FROM suppliers s
    JOIN products p ON s.supplier_id = p.supplier_id
    GROUP BY s.supplier_id, s.contact_name
    HAVING COUNT(p.product_id) > 3;
    ```

## 4. `CASE` Statement

**Objetivo:** Añadir lógica condicional (if-then-else) a las consultas.

47. **Clasificar productos por precio: 'Barato' si es < $20, 'Medio' si es entre $20 y $50, 'Caro' si es > $50.**
    ```sql
    SELECT product_name, unit_price,
           CASE
               WHEN unit_price < 20 THEN 'Barato'
               WHEN unit_price BETWEEN 20 AND 50 THEN 'Medio'
               ELSE 'Caro'
           END AS price_category
    FROM products;
    ```

48. **Mostrar el nombre del cliente y un comentario sobre su ubicación ('Local' si es de USA, 'Extranjero' si no).**
    ```sql
    SELECT contact_name, country,
           CASE
               WHEN country = 'USA' THEN 'Local'
               ELSE 'Extranjero'
           END AS location
    FROM customers;
    ```

60. **(Extra) Contar pedidos por prioridad de envío ('Normal', 'Urgente' si es de USA).**
    ```sql
    SELECT order_id, customer_id,
           CASE
               WHEN ship_country = 'USA' THEN 'Urgente'
               ELSE 'Normal'
           END AS shipping_priority
    FROM orders;
    ```

## 5. Expresiones de Tabla Comunes (CTEs - Common Table Expressions)

**Objetivo:** Simplificar consultas complejas y hacerlas más legibles. Una CTE es una tabla temporal con nombre que existe solo para la consulta.

49. **Usar una CTE para listar los clientes de Londres y luego mostrar sus pedidos.**
    ```sql
    WITH london_customers AS (
        SELECT customer_id, contact_name
        FROM customers
        WHERE city = 'London'
    )
    SELECT lc.contact_name, o.order_id
    FROM london_customers lc
    JOIN orders o ON lc.customer_id = o.customer_id;
    ```

50. **Encontrar el total de ventas por cada categoría de producto usando una CTE.**
    ```sql
    WITH product_sales AS (
        SELECT p.category_id, od.quantity * od.unit_price AS sale_amount
        FROM order_details od
        JOIN products p ON od.product_id = p.product_id
    )
    SELECT cat.category_name, SUM(ps.sale_amount) AS total_sales
    FROM product_sales ps
    JOIN categories cat ON ps.category_id = cat.category_id
    GROUP BY cat.category_name
    ORDER BY total_sales DESC;
    ```

61. **(Extra) Listar los 5 clientes con mayor gasto total.**
    ```sql
    WITH customer_spending AS (
        SELECT c.customer_id, c.contact_name, SUM(od.quantity * od.unit_price) AS total_spent
        FROM customers c
        JOIN orders o ON c.customer_id = o.customer_id
        JOIN order_details od ON o.order_id = od.order_id
        GROUP BY c.customer_id, c.contact_name
    )
    SELECT contact_name, total_spent
    FROM customer_spending
    ORDER BY total_spent DESC
    LIMIT 5;
    ```

## 6. Funciones de Ventana (Window Functions)

**Objetivo:** Realizar cálculos a través de un conjunto de filas de tabla que están de alguna manera relacionadas con la fila actual.

### `ROW_NUMBER`, `RANK`, `DENSE_RANK`
51. **Asignar un número de fila único a cada producto, ordenado por precio.**
    ```sql
    SELECT product_name, unit_price,
           ROW_NUMBER() OVER (ORDER BY unit_price DESC) AS row_num
    FROM products;
    ```

52. **Clasificar productos por precio dentro de cada categoría.**
    ```sql
    SELECT product_name, category_id, unit_price,
           RANK() OVER (PARTITION BY category_id ORDER BY unit_price DESC) AS price_rank
    FROM products;
    ```

### `LEAD` y `LAG`
53. **Para cada pedido, mostrar la fecha del pedido y la fecha del siguiente pedido del mismo cliente.**
    ```sql
    SELECT customer_id, order_date,
           LEAD(order_date, 1) OVER (PARTITION BY customer_id ORDER BY order_date) AS next_order_date
    FROM orders;
    ```
54. **Mostrar el total de una venta y el total de la venta anterior del mismo cliente.**
    ```sql
    WITH customer_sales AS (
        SELECT o.customer_id, o.order_id, o.order_date, SUM(od.quantity * od.unit_price) as order_total
        FROM orders o JOIN order_details od on o.order_id = od.order_id
        GROUP BY o.customer_id, o.order_id, o.order_date
    )
    SELECT customer_id, order_id, order_date, order_total,
           LAG(order_total, 1, 0) OVER (PARTITION BY customer_id ORDER BY order_date) AS previous_order_total
    FROM customer_sales;
    ```
### Agregaciones con `OVER`
55. **Mostrar el precio de cada producto junto con el precio promedio de su categoría.**
    ```sql
    SELECT product_name, unit_price, category_id,
           AVG(unit_price) OVER (PARTITION BY category_id) AS avg_category_price
    FROM products;
    ```

62. **(Extra) Calcular el total de ventas acumulado por mes (PostgreSQL).**
    ```sql
    WITH monthly_sales AS (
        SELECT
            TO_CHAR(order_date, 'YYYY-MM') AS sale_month,
            SUM(od.quantity * od.unit_price) AS monthly_total
        FROM orders o
        JOIN order_details od ON o.order_id = od.order_id
        GROUP BY sale_month
    )
    SELECT
        sale_month,
        monthly_total,
        SUM(monthly_total) OVER (ORDER BY sale_month) AS cumulative_total
    FROM monthly_sales;
    ```
    
67. **(Extra) Encontrar el producto más vendido en cada categoría.**
    ```sql
    WITH product_category_sales AS (
        SELECT
            p.category_id,
            p.product_name,
            SUM(od.quantity) as total_sold,
            RANK() OVER (PARTITION BY p.category_id ORDER BY SUM(od.quantity) DESC) as sales_rank
        FROM products p
        JOIN order_details od ON p.product_id = od.product_id
        GROUP BY p.category_id, p.product_name
    )
    SELECT category_id, product_name, total_sold
    FROM product_category_sales
    WHERE sales_rank = 1;
    ```

## 7. `UNION` y `UNION ALL`

**Objetivo:** Combinar el conjunto de resultados de dos o más consultas `SELECT`. `UNION` elimina duplicados, `UNION ALL` no.

56. **Obtener una lista única de todas las ciudades donde viven clientes y proveedores.**
    ```sql
    SELECT city FROM customers
    UNION
    SELECT city FROM suppliers
    ORDER BY city;
    ```
57. **Combinar los nombres de los empleados y los nombres de contacto de los clientes en una sola lista (PostgreSQL).**
    ```sql
    SELECT contact_name FROM customers
    UNION ALL
    SELECT first_name || ' ' || last_name FROM employees;
    ```

## 8. Otros Operadores

### `EXISTS`
**Objetivo:** Comprobar si una subconsulta devuelve alguna fila.

63. **Encontrar todos los clientes que han realizado al menos un pedido.**
    ```sql
    SELECT customer_id, contact_name
    FROM customers c
    WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);
    ```
    
### `ANY` y `ALL`
**Objetivo:** Comparar un valor con un conjunto de valores devueltos por una subconsulta.

64. **Encontrar productos cuyo precio es mayor que CUALQUIER producto de la categoría 1.**
    ```sql
    SELECT product_name, unit_price
    FROM products
    WHERE unit_price > ANY (SELECT unit_price FROM products WHERE category_id = 1);
    ```

## 9. Joins Adicionales
    
65. **(Extra) Listar las ventas totales por empleado.**
    ```sql
    SELECT e.first_name, e.last_name, SUM(od.quantity * od.unit_price) as total_sales
    FROM employees e
    JOIN orders o ON e.employee_id = o.employee_id
    JOIN order_details od ON o.order_id = od.order_id
    GROUP BY e.employee_id, e.first_name, e.last_name
    ORDER BY total_sales DESC;
    ```
66. **(Extra) Qué clientes han comprado qué categoría de productos.**
    ```sql
    SELECT DISTINCT c.contact_name, cat.category_name
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN order_details od ON o.order_id = od.order_id
    JOIN products p ON od.product_id = p.product_id
    JOIN categories cat ON p.category_id = cat.category_id
    ORDER BY c.contact_name, cat.category_name;
    ```
