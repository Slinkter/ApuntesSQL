# SQL Avanzado con PostgreSQL: Consultas de Alta Complejidad y Análisis de Datos

Esta sección aborda escenarios complejos que requieren un profundo conocimiento de SQL para resolver problemas de negocio, realizar análisis de datos avanzados y optimizar el rendimiento usando **PostgreSQL** y la base de datos **Northwind**.

## 1. Expresiones de Tabla Comunes Recursivas (Recursive CTEs)

**Objetivo:** Consultar datos jerárquicos, como la estructura de mando de una organización.

68. **Mostrar la jerarquía de empleados, indicando quién reporta a quién.**
    *Nota: La tabla `employees` tiene una columna `reports_to` que se refiere al `employee_id` del jefe.*
    ```sql
    WITH RECURSIVE employee_hierarchy AS (
        -- Anchor member: el nivel más alto (empleados que no reportan a nadie)
        SELECT employee_id, first_name || ' ' || last_name AS employee_name, reports_to, 0 AS Level
        FROM employees
        WHERE reports_to IS NULL

        UNION ALL

        -- Recursive member: une la CTE consigo misma para encontrar subordinados
        SELECT e.employee_id, e.first_name || ' ' || e.last_name, e.reports_to, eh.Level + 1
        FROM employees e
        INNER JOIN employee_hierarchy eh ON e.reports_to = eh.employee_id
    )
    SELECT * FROM employee_hierarchy ORDER BY Level, reports_to;
    ```

## 2. Simulación de `PIVOT`

**Objetivo:** Rotar filas en columnas. MySQL no tiene un operador `PIVOT` nativo como SQL Server, pero se puede simular con agregación condicional.

69. **Mostrar el total de pedidos por año, con cada año en una columna separada para cada cliente.**
    ```sql
    SELECT
        c.contact_name,
        SUM(CASE WHEN EXTRACT(YEAR FROM o.order_date) = 1996 THEN 1 ELSE 0 END) AS Orders1996,
        SUM(CASE WHEN EXTRACT(YEAR FROM o.order_date) = 1997 THEN 1 ELSE 0 END) AS Orders1997,
        SUM(CASE WHEN EXTRACT(YEAR FROM o.order_date) = 1998 THEN 1 ELSE 0 END) AS Orders1998
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    GROUP BY c.contact_name
    ORDER BY c.contact_name;
    ```

70. **Mostrar la cantidad total de productos vendidos por categoría, con cada categoría como una columna.**
    ```sql
    SELECT
        p.product_name,
        SUM(CASE WHEN c.category_name = 'Beverages' THEN od.quantity ELSE 0 END) AS Beverages,
        SUM(CASE WHEN c.category_name = 'Condiments' THEN od.quantity ELSE 0 END) AS Condiments,
        SUM(CASE WHEN c.category_name = 'Confections' THEN od.quantity ELSE 0 END) AS Confections
        -- ... (se pueden añadir más categorías)
    FROM order_details od
    JOIN products p ON od.product_id = p.product_id
    JOIN categories c ON p.category_id = c.category_id
    GROUP BY p.product_name
    LIMIT 10; -- Para una vista más limpia
    ```

## 3. Funciones de Ventana Avanzadas

**Objetivo:** Utilizar marcos de ventana (`ROWS BETWEEN`) para cálculos como promedios móviles.

71. **Calcular el promedio móvil de 3 días de las ventas totales.**
    ```sql
    WITH daily_sales AS (
        SELECT
            order_date,
            SUM(od.unit_price * od.quantity) AS total_sale
        FROM orders o
        JOIN order_details od ON o.order_id = od.order_id
        GROUP BY order_date
    )
    SELECT
        order_date,
        total_sale,
        AVG(total_sale) OVER (ORDER BY order_date ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS moving_avg_3_days
    FROM daily_sales;
    ```
    
## 4. Consultas Temporales y `SELF JOIN`

**Objetivo:** Unir una tabla consigo misma para comparar filas dentro de la misma tabla.

72. **Encontrar clientes que viven en la misma ciudad.**
    ```sql
    SELECT A.contact_name, B.contact_name, A.city
    FROM customers A, customers B
    WHERE A.customer_id < B.customer_id -- Evita duplicados (A,B) y (B,A) y auto-comparaciones (A,A)
    AND A.city = B.city
    ORDER BY A.city;
    ```

73. **Encontrar productos que a menudo se compran juntos (en el mismo pedido).**
    ```sql
    SELECT
        p1.product_name AS Product1,
        p2.product_name AS Product2,
        COUNT(*) AS frequency
    FROM order_details od1
    JOIN order_details od2 ON od1.order_id = od2.order_id AND od1.product_id < od2.product_id
    JOIN products p1 ON od1.product_id = p1.product_id
    JOIN products p2 ON od2.product_id = p2.product_id
    GROUP BY p1.product_name, p2.product_name
    ORDER BY frequency DESC
    LIMIT 10;
    ```

## 5. Análisis de Cohortes (Cohort Analysis)

**Objetivo:** Agrupar usuarios basados en cuándo realizaron su primera acción (p. ej., su primera compra) y seguir su comportamiento a lo largo del tiempo.

74. **Análisis de cohorte: Calcular la retención mensual de clientes.**
    ```sql
    WITH customer_first_order AS (
        SELECT
            customer_id,
            TO_CHAR(MIN(order_date), 'YYYY-MM') AS cohort_month
        FROM orders
        GROUP BY customer_id
    ),
    monthly_orders AS (
        SELECT DISTINCT
            customer_id,
            TO_CHAR(order_date, 'YYYY-MM') AS order_month
        FROM orders
    ),
    cohort_retention AS (
      SELECT
        cfo.cohort_month,
        EXTRACT(YEAR FROM AGE(TO_DATE(mo.order_month, 'YYYY-MM'), TO_DATE(cfo.cohort_month, 'YYYY-MM'))) * 12 + EXTRACT(MONTH FROM AGE(TO_DATE(mo.order_month, 'YYYY-MM'), TO_DATE(cfo.cohort_month, 'YYYY-MM'))) as months_since_first_order,
        COUNT(DISTINCT mo.customer_id) as retained_customers
      FROM customer_first_order cfo
      JOIN monthly_orders mo ON cfo.customer_id = mo.customer_id
      GROUP BY 1, 2
    )
    SELECT * FROM cohort_retention ORDER BY 1, 2;
    ```

## 6. Consultas de Integridad de Datos

**Objetivo:** Encontrar inconsistencias o problemas en los datos.

75. **Encontrar pedidos que no tienen detalles (posible error de datos).**
    ```sql
    SELECT o.order_id
    FROM orders o
    LEFT JOIN order_details od ON o.order_id = od.order_id
    WHERE od.order_id IS NULL;
    ```

76. **Verificar si hay productos con stock negativo (lo cual no debería ser posible).**
    ```sql
    SELECT * FROM products WHERE units_in_stock < 0;
    ```

77. **Encontrar duplicados en la tabla de clientes basados en el nombre de la compañía y el contacto.**
    ```sql
    SELECT company_name, contact_name, COUNT(*)
    FROM customers
    GROUP BY company_name, contact_name
    HAVING COUNT(*) > 1;
    ```
    
86. **(Extra) Listar los productos que nunca se han vendido.**
    ```sql
    SELECT p.product_name
    FROM products p
    LEFT JOIN order_details od ON p.product_id = od.product_id
    WHERE od.order_id IS NULL;
    ```

## 7. Optimización de Consultas (`EXPLAIN`)

**Objetivo:** Entender cómo la base de datos ejecuta una consulta para identificar cuellos de botella.

78. **Analizar el plan de ejecución de una consulta compleja.**
    ```sql
    EXPLAIN SELECT c.contact_name, p.product_name
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN order_details od ON o.order_id = od.order_id
    JOIN products p ON od.product_id = p.product_id
    WHERE c.country = 'Germany';
    ```
    **Cómo leer `EXPLAIN`:**
    - `type`: El tipo de join. `ALL` (full table scan) es malo. `ref`, `eq_ref`, `index` son mejores.
    - `key`: El índice que se está utilizando. Si es `NULL`, puede ser una oportunidad de mejora.
    - `rows`: El número estimado de filas que MySQL debe leer. Un número más bajo es mejor.

## 8. Escenarios de Entrevista Adicionales

79. **Encontrar el segundo empleado con más ventas.**
    ```sql
    WITH employee_sales AS (
        SELECT
            e.employee_id,
            e.first_name || ' ' || e.last_name AS employee_name,
            SUM(od.quantity * od.unit_price) AS total_sales,
            DENSE_RANK() OVER (ORDER BY SUM(od.quantity * od.unit_price) DESC) AS sales_rank
        FROM employees e
        JOIN orders o ON e.employee_id = o.employee_id
        JOIN order_details od ON o.order_id = od.order_id
        GROUP BY e.employee_id
    )
    SELECT employee_name, total_sales
    FROM employee_sales
    WHERE sales_rank = 2;
    ```

81. **(LATERAL JOIN - MySQL 8+) Obtener los 3 productos más caros de cada categoría.**
    ```sql
    -- Esto requiere MySQL 8.0+
    SELECT c.category_name, p_lat.product_name, p_lat.unit_price
    FROM categories c
    CROSS JOIN LATERAL (
        SELECT p.product_name, p.unit_price
        FROM products p
        WHERE p.category_id = c.category_id
        ORDER BY p.unit_price DESC
        LIMIT 3
    ) AS p_lat;
    ```

82. **Calcular el porcentaje del total de ventas que representa cada producto.**
    ```sql
    WITH product_sales AS (
        SELECT
            p.product_name,
            SUM(od.quantity * od.unit_price) AS product_total
        FROM order_details od
        JOIN products p ON od.product_id = p.product_id
        GROUP BY p.product_name
    ),
    total_sales AS (
        SELECT SUM(product_total) AS grand_total FROM product_sales
    )
    SELECT
        ps.product_name,
        ps.product_total,
        (ps.product_total / NULLIF(ts.grand_total, 0)) * 100 AS percentage_of_total
    FROM product_sales ps, total_sales ts
    ORDER BY percentage_of_total DESC;
    ```
    
83. **Encontrar clientes que solo han comprado productos de una única categoría.**
    ```sql
    SELECT c.contact_name
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN order_details od ON o.order_id = od.order_id
    JOIN products p ON od.product_id = p.product_id
    GROUP BY c.contact_name
    HAVING COUNT(DISTINCT p.category_id) = 1;
    ```

84. **Calcular el tiempo promedio entre pedidos para cada cliente.**
    ```sql
    WITH CustomerOrderDates AS (
        SELECT
            customer_id,
            order_date,
            LAG(order_date, 1) OVER (PARTITION BY customer_id ORDER BY order_date) as previous_order_date
        FROM orders
    )
    SELECT
        customer_id,
        AVG((order_date - previous_order_date)) AS avg_days_between_orders
    FROM CustomerOrderDates
    WHERE previous_order_date IS NOT NULL
    GROUP BY customer_id;
    ```
    
85. **Determinar el "valor de vida del cliente" (Customer Lifetime Value - LTV).**
    ```sql
    SELECT
        c.contact_name,
        SUM(od.quantity * od.unit_price) AS lifetime_value
    FROM customers c
    JOIN orders o ON c.customer_id = o.customer_id
    JOIN order_details od ON o.order_id = od.order_id
    GROUP BY c.contact_name
    ORDER BY lifetime_value DESC;
    ```

87. **Encontrar el mes con las mayores ventas para cada año.**
    ```sql
    WITH monthly_sales AS (
        SELECT
            EXTRACT(YEAR FROM order_date) AS sale_year,
            EXTRACT(MONTH FROM order_date) AS sale_month,
            SUM(od.quantity * od.unit_price) AS total_sales
        FROM orders o
        JOIN order_details od ON o.order_id = od.order_id
        GROUP BY sale_year, sale_month
    ),
    ranked_sales AS (
        SELECT
            sale_year,
            sale_month,
            total_sales,
            RANK() OVER (PARTITION BY sale_year ORDER BY total_sales DESC) AS sales_rank
        FROM monthly_sales
    )
    SELECT sale_year, sale_month, total_sales
    FROM ranked_sales
    WHERE sales_rank = 1;
    ```
    
88. **Identificar clientes "VIP": aquellos cuyo gasto total está en el 10% superior.**
    ```sql
    WITH customer_spending AS (
        SELECT
            customer_id,
            SUM(od.quantity * od.unit_price) as total_spent
        FROM orders o
        JOIN order_details od ON o.order_id = od.order_id
        GROUP BY customer_id
    ),
    ranked_spending AS (
        SELECT
            customer_id,
            total_spent,
            NTILE(10) OVER (ORDER BY total_spent DESC) as spending_decile
        FROM customer_spending
    )
    SELECT c.contact_name, rs.total_spent
    FROM ranked_spending rs
    JOIN customers c ON rs.customer_id = c.customer_id
    WHERE rs.spending_decile = 1; -- El primer decil (top 10%)
    ```

90. **Encontrar el producto más popular (en nº de pedidos) de cada proveedor.**
    ```sql
    WITH product_popularity AS (
        SELECT
            p.supplier_id,
            p.product_name,
            COUNT(DISTINCT od.order_id) AS number_of_orders,
            ROW_NUMBER() OVER (PARTITION BY p.supplier_id ORDER BY COUNT(DISTINCT od.order_id) DESC) as popularity_rank
        FROM products p
        JOIN order_details od ON p.product_id = od.product_id
        GROUP BY p.supplier_id, p.product_name
    )
    SELECT s.contact_name as Supplier, pp.product_name, pp.number_of_orders
    FROM product_popularity pp
    JOIN suppliers s ON pp.supplier_id = s.supplier_id
    WHERE pp.popularity_rank = 1;
    ```
    
91. **Calcular la diferencia (en días) entre la fecha de un pedido y la fecha del primer pedido de ese cliente.**
    ```sql
    WITH first_order_date AS (
        SELECT customer_id, MIN(order_date) AS first_date
        FROM orders
        GROUP BY customer_id
    )
    SELECT
        o.order_id,
        o.customer_id,
        o.order_date,
        fo.first_date,
        (o.order_date - fo.first_date) AS days_since_first_order
    FROM orders o
    JOIN first_order_date fo ON o.customer_id = fo.customer_id
    ORDER BY o.customer_id, o.order_date;
    ```

93. **Ventas por trimestre para el año 1997.**
    ```sql
    SELECT
        EXTRACT(QUARTER FROM order_date) AS Quarter,
        SUM(od.quantity * od.unit_price) as quarterly_sales
    FROM orders o
    JOIN order_details od ON o.order_id = od.order_id
    WHERE EXTRACT(YEAR FROM order_date) = 1997
    GROUP BY EXTRACT(QUARTER FROM order_date)
    ORDER BY Quarter;
    ```
    
94. **Listar clientes que no han comprado en los últimos 6 meses (desde la última fecha de pedido en la BD).**
    ```sql
    SELECT c.contact_name
    FROM customers c
    WHERE c.customer_id NOT IN (
        SELECT DISTINCT customer_id
        FROM orders
        WHERE order_date >= (SELECT (MAX(order_date) - INTERVAL '6 months') FROM orders)
    );
    ```

95. **Obtener el crecimiento de ventas mes a mes en porcentaje.**
    ```sql
    WITH monthly_sales AS (
        SELECT
            TO_CHAR(order_date, 'YYYY-MM') AS sale_month,
            SUM(od.quantity * od.unit_price) AS monthly_total
        FROM orders o
        JOIN order_details od ON o.order_id = od.order_id
        GROUP BY sale_month
    ),
    sales_with_lag AS (
        SELECT
            sale_month,
            monthly_total,
            LAG(monthly_total, 1, 0) OVER (ORDER BY sale_month) AS previous_month_total
        FROM monthly_sales
    )
    SELECT
        sale_month,
        monthly_total,
        previous_month_total,
        ( (monthly_total - previous_month_total) / previous_month_total ) * 100 AS growth_percentage
    FROM sales_with_lag
    WHERE previous_month_total > 0;
    ```
    
96. **Encontrar el número promedio de productos por pedido para cada cliente.**
    ```sql
    WITH products_per_order AS (
        SELECT
            o.customer_id,
            o.order_id,
            COUNT(od.product_id) AS product_count
        FROM orders o
        JOIN order_details od ON o.order_id = od.order_id
        GROUP BY o.customer_id, o.order_id
    )
    SELECT
        c.contact_name,
        AVG(ppo.product_count) AS avg_products_per_order
    FROM customers c
    JOIN products_per_order ppo ON c.customer_id = ppo.customer_id
    GROUP BY c.contact_name
    ORDER BY avg_products_per_order DESC;
    ```

97. **Identificar si un cliente es 'Nuevo' o 'Recurrente' en cada pedido.**
    ```sql
    WITH ordered_orders AS (
      SELECT
        customer_id,
        order_date,
        ROW_NUMBER() OVER(PARTITION BY customer_id ORDER BY order_date) as rn
      FROM orders
    )
    SELECT
      oo.customer_id,
      oo.order_date,
      CASE WHEN oo.rn = 1 THEN 'Nuevo' ELSE 'Recurrente' END as CustomerType
    FROM ordered_orders oo;
    ```

98. **Ranking de productos por ventas totales dentro de cada país.**
    ```sql
    WITH country_product_sales AS (
        SELECT
            c.country,
            p.product_name,
            SUM(od.quantity * od.unit_price) as total_sales
        FROM orders o
        JOIN customers c ON o.customer_id = o.customer_id
        JOIN order_details od ON o.order_id = od.order_id
        JOIN products p ON od.product_id = p.product_id
        GROUP BY c.country, p.product_name
    ),
    ranked_sales AS (
        SELECT
            country,
            product_name,
            total_sales,
            RANK() OVER (PARTITION BY country ORDER BY total_sales DESC) as sales_rank
        FROM country_product_sales
    )
    SELECT country, product_name, total_sales
    FROM ranked_sales
    WHERE sales_rank <= 3 -- Top 3 de cada país
    ORDER BY country, sales_rank;
    ```
    
99. **Encontrar el proveedor con el margen de ganancia promedio más alto (simulado).**
    ```sql
    -- Asumimos que el costo es 70% del unit_price
    SELECT
        s.contact_name,
        AVG(p.unit_price / (p.unit_price * 0.7) - 1) * 100 as avg_profit_margin
    FROM products p
    JOIN suppliers s ON p.supplier_id = s.supplier_id
    WHERE p.unit_price > 0
    GROUP BY s.contact_name
    ORDER BY avg_profit_margin DESC;
    ```
    
100. **Análisis de "Market Basket": ¿Qué producto se vende más frecuentemente con 'Chai'?**
    ```sql
    WITH chai_orders AS (
        -- Encontrar todos los pedidos que contienen 'Chai'
        SELECT DISTINCT od.order_id
        FROM order_details od
        JOIN products p ON od.product_id = p.product_id
        WHERE p.product_name = 'Chai'
    )
    SELECT
        p.product_name,
        COUNT(DISTINCT od.order_id) AS frequency
    FROM order_details od
    JOIN products p ON od.product_id = p.product_id
    WHERE od.order_id IN (SELECT order_id FROM chai_orders)
      AND p.product_name != 'Chai' -- No contarnos a nosotros mismos
    GROUP BY p.product_name
    ORDER BY frequency DESC
    LIMIT 5;
    ```
